/*==============================================================================*/
/*	参考)																		*/
/*	http://www.geocities.jp/ellery2011/text/no9.html							*/
/*	http://d.hatena.ne.jp/piraki/20090507/1241671908							*/
/*	http://programming.blogo.jp/c/inverse_fourier_transform						*/
/*------------------------------------------------------------------------------*/
/*	使用例)																		*/
/*	①FFT処理実施																*/
/*	　void fft( in , N , ar ,ai , p );											*/
/*	②ar,aiに対しフィルタリング処理を実施										*/
/*	③逆FFT処理実施																*/
/*	　void ifft( ar , ai , N , ot );											*/
/*==============================================================================*/
/*==============================================================================*/
/* include																		*/
/*==============================================================================*/
#include	<stdio.h>
#include	<stdlib.h>
#include	<math.h>
/*==============================================================================*/
static const int Range_ = 256;
static const short Table_[] = {
10000	,
9996	,
9987	,
9972	,
9951	,
9924	,
9891	,
9852	,
9807	,
9757	,
9700	,
9637	,
9569	,
9495	,
9415	,
9329	,
9238	,
9142	,
9039	,
8932	,
8819	,
8700	,
8577	,
8448	,
8314	,
8175	,
8032	,
7883	,
7730	,
7572	,
7409	,
7242	,
7071	,
6895	,
6715	,
6531	,
6344	,
6152	,
5957	,
5758	,
5555	,
5350	,
5141	,
4929	,
4714	,
4496	,
4275	,
4052	,
3827	,
3599	,
3369	,
3137	,
2903	,
2667	,
2430	,
2191	,
1951	,
1710	,
1467	,
1224	,
980	,
736	,
491	,
245	,
0	,
-245	,
-491	,
-736	,
-980	,
-1224	,
-1467	,
-1710	,
-1951	,
-2191	,
-2430	,
-2667	,
-2903	,
-3137	,
-3369	,
-3599	,
-3827	,
-4052	,
-4276	,
-4496	,
-4714	,
-4929	,
-5141	,
-5350	,
-5556	,
-5758	,
-5957	,
-6152	,
-6344	,
-6532	,
-6716	,
-6895	,
-7071	,
-7242	,
-7410	,
-7572	,
-7730	,
-7884	,
-8032	,
-8176	,
-8315	,
-8449	,
-8577	,
-8701	,
-8819	,
-8932	,
-9040	,
-9142	,
-9239	,
-9330	,
-9416	,
-9496	,
-9570	,
-9638	,
-9701	,
-9757	,
-9808	,
-9853	,
-9892	,
-9925	,
-9952	,
-9973	,
-9988	,
-9997	,
-10000	,
-9998	,
-9989	,
-9973	,
-9952	,
-9925	,
-9892	,
-9853	,
-9809	,
-9758	,
-9701	,
-9639	,
-9570	,
-9496	,
-9416	,
-9331	,
-9240	,
-9143	,
-9041	,
-8933	,
-8820	,
-8702	,
-8578	,
-8450	,
-8316	,
-8177	,
-8033	,
-7885	,
-7731	,
-7573	,
-7411	,
-7244	,
-7072	,
-6897	,
-6717	,
-6533	,
-6345	,
-6154	,
-5958	,
-5760	,
-5557	,
-5352	,
-5143	,
-4931	,
-4716	,
-4498	,
-4277	,
-4054	,
-3829	,
-3601	,
-3371	,
-3139	,
-2905	,
-2669	,
-2432	,
-2193	,
-1953	,
-1711	,
-1469	,
-1226	,
-982	,
-738	,
-493	,
-247	,
-2	,
244	,
489	,
734	,
978	,
1222	,
1465	,
1708	,
1949	,
2189	,
2428	,
2665	,
2901	,
3135	,
3367	,
3597	,
3825	,
4051	,
4274	,
4494	,
4712	,
4927	,
5139	,
5348	,
5554	,
5756	,
5955	,
6151	,
6342	,
6530	,
6714	,
6894	,
7069	,
7241	,
7408	,
7571	,
7729	,
7882	,
8031	,
8174	,
8313	,
8447	,
8576	,
8700	,
8818	,
8931	,
9039	,
9141	,
9238	,
9329	,
9414	,
9494	,
9568	,
9637	,
9699	,
9756	,
9807	,
9852	,
9891	,
9924	,
9951	,
9972	,
9987	,
9996	,
0	,
};

#if 0
static double mySin(int X, int Y);
static double myCos(int X, int Y);
#endif

// 高速化対応のためカスタムしている
// 虚数部は0で使用するためカットする
// double -> intで計算 -> 最後にdoubleに戻す
/*==============================================================================*/
/*	ifft																		*/
/*==============================================================================*/
void ifft
(
	short	ar[] ,	/* IN：実数部												*/
	int		N 	 ,	/* IN：要素数												*/
	double	ot[] 	/* OT：逆生成データ											*/
)
{
	int		n;
	int		k;
	long	Ref;
	int pos;
	long tmp;

	for( k=0 ; k<N ; k++ )
	{
		Ref = 0.0;
		pos = 0;
		for( n=0 ;  n<N ; n++ )
		{
			if(pos >= Range_){
				pos -= Range_;
			}
			tmp = (long)ar[n];
			tmp = tmp * (long)Table_[pos];
			Ref += tmp;
			pos += k;
		}
		ot[k] = Ref / (double)(N);
		ot[k] /= 10000;
		ot[k] /= 1000;
	}
}

#if 0
static double myCos(int X, int Y)
{
	int pos = 0;
	// 0
	Y += 64;
	pos = X*Y % Range_;
	return Table_[pos];
}

static double mySin(int X, int Y)
{
	int pos = X*Y % Range_;
	return Table_[pos];
}

void ifft
(
	double	ar[] ,	/* IN：実数部												*/
	int		N 	 ,	/* IN：要素数												*/
	double	ot[] 	/* OT：逆生成データ											*/
)
{
	int		n;
	int		k;
	double	Ref;
	int pos;

	for( k=0 ; k<N ; k++ )
	{
		Ref = 0.0;
		pos = 64;
		for( n=0 ;  n<N ; n++ )
		{
			pos += k;
			if(pos >= Range_){
				pos -= Range_;
			}
			Ref += ar[n]*Table_[pos];
//			Ref += ( ar[n]*cos(2*pi*k*n/N ) - ai[n]*sin(2*pi*k*n/N));
		}
		Ref /= ((double)N);
		ot[ k ] = Ref;
	}
}
#endif
/* EOF */